#include "Square.h"


using namespace NDChess;

Square::ColorBit Square::getColor() const {
	return (ColorBit)(data & COLOR_MASK);
}

Square::PieceTypeBit Square::getPieceType() const {
	return (PieceTypeBit)(data & PIECE_TYPE_MASK);
}

Square::InCheckBit Square::getInCheck() const {
	return (InCheckBit)(data & IN_CHECK_MASK);
}

bool Square::isPieceHere() const {
	return (bool)(data & PIECE_HERE_MASK);
}

/*Adapted from code generated by Google Gemini*/
void Square::setColor(ColorBit color) {
	data = (data & ~COLOR_MASK) | (uint8_t)color;
}

void Square::setPieceType(PieceTypeBit type) {
	data = (data & ~PIECE_TYPE_MASK) | (uint8_t)type;
}

void Square::setInCheck(InCheckBit inCheck) {
	if (getPieceType() != PieceTypeBit::KING) {
		return;
	}

	data = (data & ~IN_CHECK_MASK) | (uint8_t)inCheck;
}

void Square::setPieceHere(PieceHereBit pieceHere) {
	data - (data & ~PIECE_HERE_MASK) | (uint8_t)pieceHere;
}

std::ostream& operator<<(std::ostream& os, Square& rhs) {
	char display = '-';
	
	if (rhs.isPieceHere()) {
		switch (rhs.getPieceType()) {
		case Square::PieceTypeBit::PAWN:
			display = 'p';
			break;
		case Square::PieceTypeBit::KNIGHT:
			display = 'n';
			break;
		case Square::PieceTypeBit::BISHOP:
			display = 'b';
			break;
		case Square::PieceTypeBit::QUEEN:
			display = 'b';
			break;
		case Square::PieceTypeBit::KING:
			display = 'k';
		}

		if (rhs.getColor() == Square::ColorBit::BLACK) {
			display -= 32;
		}
	}

	os << display;
	return os;
}